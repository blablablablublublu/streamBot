import re
import requests
import logging
import asyncio
import threading
from datetime import datetime, timedelta
import telebot
from flask import Flask, request, abort
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from tenacity import retry, stop_after_attempt, wait_fixed, retry_if_exception_type
import pytz

# ---------------- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è ----------------
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ---------------- –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è ----------------
BOT_TOKEN = "8041256909:AAGP38US7WMqPKP1FXCM59M_Abx0Q6nBtBk"
YOUTUBE_API_KEY = "AIzaSyB1GlNtoCX2d2BM67n20hFeOqJ51nMZvnM"
CHANNEL_ID = "UCV1X9pvOdGnY5ZvmhifMKcw"  # –æ–Ω–æ–≤–ª–µ–Ω–æ –∑ https://www.youtube.com/channel/UCV1X9pvOdGnY5ZvmhifMKcw
TIKTOK_USERNAME = "skarbnychka._uzin"    # –ø—Ä–∏–∫–ª–∞–¥ –∫–∞–Ω–∞–ª—É, –¥–µ –∑–∞—Ä–∞–∑ live
TELEGRAM_CHANNEL = "@testbotika12"
TWITCH_CLIENT_ID = "your_twitch_client_id"         # –∑–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω–∏–π, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω
TWITCH_CLIENT_SECRET = "your_twitch_client_secret"   # –∑–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω–∏–π, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω
TWITCH_LOGIN = "dmqman"
WEBHOOK_URL_BASE = "https://streambot-yzkw.onrender.com"
WEBHOOK_ROUTE = "/webhook"
full_webhook_url = f"{WEBHOOK_URL_BASE}{WEBHOOK_ROUTE}?token={BOT_TOKEN}"

# ---------------- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Flask —ñ Telegram Bot ----------------
app = Flask(__name__)
bot = telebot.TeleBot(BOT_TOKEN, parse_mode="HTML")
active_streams = {"YouTube": False, "TikTok": False, "Twitch": False}

# –ó–º—ñ–Ω–Ω—ñ –¥–ª—è –∫–µ—à—É–≤–∞–Ω–Ω—è —Ç–æ–∫–µ–Ω–∞ Twitch
twitch_token = None
token_expiry = None

# ---------------- –ì–ª–æ–±–∞–ª—å–Ω–∏–π asyncio event loop ----------------
ASYNC_LOOP = asyncio.new_event_loop()
asyncio.set_event_loop(ASYNC_LOOP)
threading.Thread(target=ASYNC_LOOP.run_forever, daemon=True).start()

def safe_async_send(coro, timeout=10):
    """
    –í–∏–∫–æ–Ω—É—î coroutine —á–µ—Ä–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω–∏–π event loop.
    –Ø–∫—â–æ loop –∑–∞–∫—Ä–∏—Ç–∏–π, —Å—Ç–≤–æ—Ä—é—î –Ω–æ–≤–∏–π.
    """
    try:
        return asyncio.run_coroutine_threadsafe(coro, ASYNC_LOOP).result(timeout=timeout)
    except RuntimeError as e:
        if "Event loop is closed" in str(e):
            global ASYNC_LOOP
            ASYNC_LOOP = asyncio.new_event_loop()
            asyncio.set_event_loop(ASYNC_LOOP)
            threading.Thread(target=ASYNC_LOOP.run_forever, daemon=True).start()
            return asyncio.run_coroutine_threadsafe(coro, ASYNC_LOOP).result(timeout=timeout)
        else:
            logger.error("safe_async_send exception: %s", e)
            raise

def in_grey_zone(tz="Europe/Kiev") -> bool:
    """–ü–æ–≤–µ—Ä—Ç–∞—î True, —è–∫—â–æ –∑–∞—Ä–∞–∑ –º—ñ–∂ 2:00 —ñ 12:00 (—á–∞—Å–æ–≤–∞ –∑–æ–Ω–∞ tz)."""
    now = datetime.now(pytz.timezone(tz))
    return 2 <= now.hour < 12

@retry(stop=stop_after_attempt(3), wait=wait_fixed(2), retry=retry_if_exception_type((requests.RequestException,)))
def make_request(url, headers=None, params=None):
    return requests.get(url, headers=headers, params=params, timeout=5)

# ---------------- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ YouTube ----------------
async def check_youtube_live():
    """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å—Ç—Ä—ñ–º—É –Ω–∞ YouTube —á–µ—Ä–µ–∑ API –∞–±–æ HTML."""
    try:
        if YOUTUBE_API_KEY:
            url = (
                "https://www.googleapis.com/youtube/v3/search"
                f"?part=snippet&channelId={CHANNEL_ID}&eventType=live&type=video&key={YOUTUBE_API_KEY}"
            )
            resp = await asyncio.to_thread(make_request, url)
            data = resp.json()
            if data.get("items"):
                video_id = data["items"][0]["id"]["videoId"]
                return True, f"https://www.youtube.com/watch?v={video_id}"
        return await check_youtube_live_html()
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ YouTube: %s", e)
        return False, None

async def check_youtube_live_html():
    """–ó–∞–ø–∞—Å–Ω–∏–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ YouTube —á–µ—Ä–µ–∑ HTML."""
    try:
        url = f"https://www.youtube.com/channel/{CHANNEL_ID}/live"
        headers = {"User-Agent": "Mozilla/5.0"}
        resp = await asyncio.to_thread(make_request, url, headers=headers)
        soup = BeautifulSoup(resp.text, 'html.parser')
        live_indicator = soup.find("meta", {"name": "description"})
        live_badge = soup.find("span", string=re.compile("LIVE", re.I))
        is_live = live_indicator and "live" in live_indicator["content"].lower() and live_badge is not None
        logger.info("YouTube HTML: is_live=%s", is_live)
        return is_live, url if is_live else None
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ YouTube HTML: %s", e)
        return False, None

# ---------------- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ TikTok ----------------
async def check_tiktok_live():
    """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —Å—Ç—Ä—ñ–º—É –Ω–∞ TikTok —á–µ—Ä–µ–∑ Selenium —ñ–∑ —è–≤–Ω–∏–º –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è–º."""
    try:
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        options.add_argument("--disable-gpu")
        options.add_argument("--no-sandbox")
        options.add_argument("user-agent=Mozilla/5.0")
        with webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options) as driver:
            url = f"https://www.tiktok.com/@{TIKTOK_USERNAME}/live"
            driver.get(url)
            wait = WebDriverWait(driver, 15)
            # –®—É–∫–∞—î–º–æ –µ–ª–µ–º–µ–Ω—Ç —ñ–∑ —Ç–µ–∫—Å—Ç–æ–º, —â–æ –º—ñ—Å—Ç–∏—Ç—å "live" –∞–±–æ "–ø—Ä—è–º–∏–π –µ—Ñ—ñ—Ä" (–±–µ–∑ —Ä–µ—î—Å—Ç—Ä—É)
            xpath_expr = (
                "//*[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), 'live') or "
                "contains(translate(text(), '–ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–Æ–Ø', '–∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—é—è'), '–ø—Ä—è–º–∏–π –µ—Ñ—ñ—Ä')]"
            )
            try:
                element = wait.until(EC.presence_of_element_located((By.XPATH, xpath_expr)))
                is_live = True
            except Exception as ex:
                logger.error("TikTok: –µ–ª–µ–º–µ–Ω—Ç live –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ: %s", ex)
                is_live = False
            # –î–ª—è –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ª–æ–≥—É–≤–∞–Ω–Ω—è HTML (–ø–µ—Ä—à—ñ 1000 —Å–∏–º–≤–æ–ª—ñ–≤)
            html_sample = driver.page_source[:1000]
            logger.info("TikTok HTML sample: %s", html_sample)
            return is_live, url if is_live else None
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ TikTok: %s", e)
        return False, None

# ---------------- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ Twitch ----------------
async def get_twitch_token():
    global twitch_token, token_expiry
    if twitch_token and token_expiry and token_expiry > datetime.now():
        return twitch_token
    try:
        token_url = "https://id.twitch.tv/oauth2/token"
        params = {
            "client_id": TWITCH_CLIENT_ID,
            "client_secret": TWITCH_CLIENT_SECRET,
            "grant_type": "client_credentials"
        }
        token_resp = await asyncio.to_thread(requests.post, token_url, params=params, timeout=5)
        data = token_resp.json()
        twitch_token = data.get("access_token")
        token_expiry = datetime.now() + timedelta(seconds=data.get("expires_in", 3600))
        return twitch_token
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–æ–∫–µ–Ω–∞ Twitch: %s", e)
        return None

async def check_twitch_live():
    try:
        if TWITCH_CLIENT_ID and TWITCH_CLIENT_SECRET:
            token = await get_twitch_token()
            if not token:
                return False, None
            headers = {"Client-ID": TWITCH_CLIENT_ID, "Authorization": f"Bearer {token}"}
            stream_resp = await asyncio.to_thread(make_request, "https://api.twitch.tv/helix/streams", headers=headers, params={"user_login": TWITCH_LOGIN})
            if stream_resp.json().get("data"):
                return True, f"https://www.twitch.tv/{TWITCH_LOGIN}"
        return False, None
    except Exception as e:
        logger.error("–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ Twitch: %s", e)
        return False, None

# ---------------- –§–æ–Ω–æ–≤—ñ –∑–∞–≤–¥–∞–Ω–Ω—è ----------------
async def check_streams_and_notify_async():
    while True:
        if in_grey_zone():
            logger.info("–°—ñ—Ä–∞ –∑–æ–Ω–∞ ‚Äì –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤–∏–º–∫–Ω–µ–Ω–æ.")
            await asyncio.sleep(300)
            continue
        for platform, check_func in [
            ("YouTube", check_youtube_live),
            ("TikTok", check_tiktok_live),
            ("Twitch", check_twitch_live)
        ]:
            is_live, link = await check_func()
            if is_live and not active_streams[platform]:
                active_streams[platform] = True
                message = f"üî¥ {platform} —Å—Ç—Ä—ñ–º –ø–æ—á–∞–≤—Å—è: {link}"
                try:
                    safe_async_send(bot.send_message(TELEGRAM_CHANNEL, message))
                    logger.info("–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–ª—è %s", platform)
                except Exception as err:
                    logger.error("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è –¥–ª—è %s: %s", platform, err)
            elif not is_live and active_streams[platform]:
                active_streams[platform] = False
        await asyncio.sleep(300)

async def verify_webhook():
    while True:
        try:
            webhook_info = bot.get_webhook_info()
            if not webhook_info.url or webhook_info.url != full_webhook_url:
                bot.set_webhook(url=full_webhook_url)
                logger.info("Webhook –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ: %s", full_webhook_url)
        except Exception as e:
            logger.error("–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –≤–µ–±—Ö—É–∫–∞: %s", e)
        await asyncio.sleep(3600)

def start_background_tasks():
    safe_async_send(check_streams_and_notify_async())
    safe_async_send(verify_webhook())

# ---------------- Telegram bot —Ö–µ–Ω–¥–ª–µ—Ä–∏ ----------------
@bot.message_handler(commands=['start'])
def handle_start(message):
    safe_async_send(bot.reply_to(message, "–ë–æ—Ç –ø—Ä–∞—Ü—é—î! –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —Å—Ç—Ä—ñ–º—ñ–≤ —É–≤—ñ–º–∫–Ω–µ–Ω–æ."))

@bot.message_handler(commands=['checkstreams'])
def handle_check_streams(message):
    async def process():
        results = []
        for platform, check_func in [
            ("YouTube", check_youtube_live),
            ("TikTok", check_tiktok_live),
            ("Twitch", check_twitch_live)
        ]:
            is_live, link = await check_func()
            if is_live:
                results.append(f"{platform}: {link}")
                channel_msg = f"üî¥ {platform} —Å—Ç—Ä—ñ–º –∞–∫—Ç–∏–≤–Ω–∏–π: {link}"
                try:
                    await bot.send_message(TELEGRAM_CHANNEL, channel_msg)
                    logger.info("–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è –≤ –∫–∞–Ω–∞–ª –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–ª—è %s", platform)
                except Exception as err:
                    logger.error("–ü–æ–º–∏–ª–∫–∞ –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è –≤ –∫–∞–Ω–∞–ª –¥–ª—è %s: %s", platform, err)
        response = "üî¥ –ê–∫—Ç–∏–≤–Ω—ñ —Å—Ç—Ä—ñ–º–∏:\n" + "\n".join(results) if results else "–ó–∞—Ä–∞–∑ —Å—Ç—Ä—ñ–º—ñ–≤ –Ω–µ–º–∞—î."
        await bot.reply_to(message, response)
    safe_async_send(process())

@bot.message_handler(content_types=['text'])
def handle_text(message):
    safe_async_send(bot.reply_to(message, f"–ü—Ä–∏–≤—ñ—Ç, —Ç–∏ –Ω–∞–ø–∏—Å–∞–≤: {message.text}"))

@bot.callback_query_handler(func=lambda call: True)
def handle_callback(call):
    async def process_callback():
        await call.answer()
    safe_async_send(process_callback())

# ---------------- Flask webhook –º–∞—Ä—à—Ä—É—Ç ----------------
@app.route(WEBHOOK_ROUTE, methods=["POST"])
def webhook():
    if request.args.get("token") != BOT_TOKEN:
        abort(403)
    if request.headers.get("content-type") == "application/json":
        json_string = request.get_data().decode("utf-8")
        update = telebot.types.Update.de_json(json_string)
        try:
            safe_async_send(bot.process_new_updates([update]))
        except Exception as e:
            logger.error("–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ update: %s", e)
        return ""
    else:
        abort(403)

@app.route("/")
def index():
    return "–ë–æ—Ç –ø—Ä–∞—Ü—é—î —á–µ—Ä–µ–∑ webhook!"

# ---------------- –ó–∞–ø—É—Å–∫ –¥–æ–¥–∞—Ç–∫—É ----------------
if __name__ == "__main__":
    bot.remove_webhook()
    if bot.set_webhook(url=full_webhook_url):
        logger.info("Webhook –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: %s", full_webhook_url)
    else:
        logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ webhook –Ω–∞: %s", full_webhook_url)
    start_background_tasks()
    port = 5000
    app.run(host="0.0.0.0", port=port)


















